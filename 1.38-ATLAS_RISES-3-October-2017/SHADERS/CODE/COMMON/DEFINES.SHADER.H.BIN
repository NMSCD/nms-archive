// =================================================================================================

#ifndef D_DEFINES
#define D_DEFINES


// =================================================================================================
// Platform defines
// =================================================================================================
#ifdef D_PLATFORM_PC

    #define D_ENABLE_REVERSEZ_PROJECTION  (1)

    #pragma optionNV(strict on)
    #extension GL_ARB_gpu_shader5 : enable
    #extension GL_ARB_fragment_coord_conventions : enable
    #extension GL_ARB_derivative_control : enable


    #if defined( D_FRAGMENT ) && defined( _F64_ )

        layout(early_fragment_tests) in;

#endif

#elif defined(D_PLATFORM_ORBIS)

    #define D_ENABLE_REVERSEZ_PROJECTION  (1)

    // use this with sdk 2.0 compiler 
   // #pragma argument (allow-scratch-buffer-spill)

    //define these flags so they don't get ignored in build process and in the comb mask
    //this is because materials, vertex layouts and shaders need to be synced on 360 to avoid patching
    #ifdef _F27_VBTANGENT
    #endif
    #ifdef _F28_VBSKINNED
    #endif
    #ifdef _F29_VBCOLOUR
    #endif
    #ifdef _F21_VERTEXCOLOUR
    #endif
    #ifdef _F02_SKINNED
    #endif
    #ifdef _F03_NORMALMAP
    #endif
    #if defined( _F01_DIFFUSEMAP ) || defined( D_LOD0 ) || defined( D_LOD1 ) || defined( D_LOD2 ) || defined( D_LOD3) || defined( D_LOD4 ) 
    #endif
    #ifdef _F01_DIFFUSEMAP
    #endif
    #ifdef _F09_TRANSPARENT
    #endif
    #ifdef _F10_NORECEIVESHADOW
    #endif


    // disable warnings for unused parameters. This happens a lot because of defining different things.
    #pragma warning (disable: 5203)

    // temp thing to know what things are still required on ps4.
    #define D_PLATFORM_ORBIS_FIX

    #ifdef __PSSL_CS__
    #define D_PLATFORM_ORBIS_COMPUTE
    #endif

    #ifdef __PSSL_HS__
    #define D_HULL
    #endif

    #ifdef __PSSL_DS__
    #define D_DOMAIN
    #endif

    #ifdef __PSSL_VS__
    #define D_VERTEX
    #endif

    #ifdef __PSSL_GS__
    #define D_GEOMETRY
    #endif

#endif

#if !D_ENABLE_REVERSEZ_PROJECTION
#define D_USING_LOGDEPTH
#endif


// =================================================================================================
// Basic Types
// =================================================================================================
#ifdef D_PLATFORM_PC

    #define JOINT_TYPE    vec4

    //#define CONST         const
    #define STATIC_CONST  const

#elif defined(D_PLATFORM_ORBIS)

    #define JOINT_TYPE      int4
    #define float           float
    #define vec2            float2
    #define vec3            float3
    #define vec4            float4
    #define ivec2           int2
    #define ivec3           int3
    #define ivec4           int4
    #define uvec2           uint2
    #define uvec3           uint3
    #define uvec4           uint4
    // NOTE: 
    // operator[] accesses rows, not columns 
    // matrix constructors interpret the passed vectors as row vectors, not column vectors
    #define mat2            row_major float2x2
    #define mat3            row_major float3x3
    #define mat4            row_major float4x4

    //#define CONST           
    #define STATIC_CONST    static const
   // #define const           ERROR, DON'T USE CONST FOR PS4. USE STATIC_CONST INSTEAD FOR A COMPILED IN CONSTANT. OTHERWISE IT TRIES TO PUT IT IN A CONSTANT BUFFER AND FOR SOME REASON IT DOESN'T WORK.


#endif

// =================================================================================================
// Functions
// =================================================================================================
#ifdef D_PLATFORM_PC

    #define saturate( V )  min( max( V, 0.0) , 1.0)
    #define atan2( Y, X )  atan( Y, X )
    #define invsqrt( X )   inversesqrt( X )

#ifdef D_COMPUTE

    #define groupID           gl_WorkGroupID
    #define groupThreadID     gl_LocalInvocationID
    #define dispatchThreadID  gl_GlobalInvocationID

#endif

#elif defined(D_PLATFORM_ORBIS)

#if defined(D_PLATFORM_ORBIS_COMPUTE)

    float dFdx( float var ) { float delta = var - LaneSwizzle( var, 0x1f, 0, 1 ); return __v_cndmask_b32(0, 1, 0xAAAAAAAAAAAAAAAA ) ? delta : -delta;  }
    float dFdy( float var ) { float delta = var - LaneSwizzle( var, 0x1f, 0, 8 ); return __v_cndmask_b32(0, 1, 0xFF00FF00FF00FF00 ) ? delta : -delta;  }

    vec2 dFdx( vec2 var ) { vec2 delta = vec2( var.x - LaneSwizzle( var.x, 0x1f, 0, 1 ), var.y - LaneSwizzle( var.y, 0x1f, 0, 1 ) ); return __v_cndmask_b32(0, 1, 0xAAAAAAAAAAAAAAAA ) ? delta : -delta;  }
    vec2 dFdy( vec2 var ) { vec2 delta = vec2( var.x - LaneSwizzle( var.x, 0x1f, 0, 8 ), var.y - LaneSwizzle( var.y, 0x1f, 0, 8 ) ); return __v_cndmask_b32(0, 1, 0xFF00FF00FF00FF00 ) ? delta : -delta;  }

    vec3 dFdx( vec3 var ) { vec3 delta = vec3( var.x - LaneSwizzle( var.x, 0x1f, 0, 1 ), var.y - LaneSwizzle( var.y, 0x1f, 0, 1 ), var.z - LaneSwizzle( var.z, 0x1f, 0, 1 ) ); return __v_cndmask_b32(0, 1, 0xAAAAAAAAAAAAAAAA ) ? delta : -delta;  }
    vec3 dFdy( vec3 var ) { vec3 delta = vec3( var.x - LaneSwizzle( var.x, 0x1f, 0, 8 ), var.y - LaneSwizzle( var.y, 0x1f, 0, 8 ), var.z - LaneSwizzle( var.z, 0x1f, 0, 8 ) ); return __v_cndmask_b32(0, 1, 0xFF00FF00FF00FF00 ) ? delta : -delta;  }

    vec4 dFdx( vec4 var ) { vec4 delta = vec4( var.x - LaneSwizzle( var.x, 0x1f, 0, 1 ), var.y - LaneSwizzle( var.y, 0x1f, 0, 1 ), var.z - LaneSwizzle( var.z, 0x1f, 0, 1 ), var.z - LaneSwizzle( var.w, 0x1f, 0, 1 ) ); return __v_cndmask_b32(0, 1, 0xAAAAAAAAAAAAAAAA ) ? delta : -delta;  }
    vec4 dFdy( vec4 var ) { vec4 delta = vec4( var.x - LaneSwizzle( var.x, 0x1f, 0, 8 ), var.y - LaneSwizzle( var.y, 0x1f, 0, 8 ), var.z - LaneSwizzle( var.z, 0x1f, 0, 8 ), var.z - LaneSwizzle( var.w, 0x1f, 0, 8 ) ); return __v_cndmask_b32(0, 1, 0xFF00FF00FF00FF00 ) ? delta : -delta;  }


    #define dFdxFine        dFdx
    #define dFdyFine        dFdy

#else

    #define dFdx            ddx
    #define dFdy            ddy
    #define dFdxFine        ddx_fine
    #define dFdyFine        ddy_fine

#endif

    #define mix             lerp
    #define fract           frac
    #define mod				fmod
    #define saturate( V )   ( min( max( V, 0.0) , 1.0) )
    #define invsqrt( X )    rsqrt( X )

#endif


// =================================================================================================
// Samplers and textures
// =================================================================================================
#ifdef D_PLATFORM_PC

    #define shadow2D( S, UV )				texture( S, UV )

    #define SAMPLER2DSHADOW( NAME, REG )    uniform sampler2DShadow NAME

    #define SAMPLERCUBE( NAME )             samplerCube NAME
    #define SAMPLERCUBEARG( NAME )          in samplerCube NAME
    #define SAMPLERCUBEPARAM( NAME )        NAME

    #define imageAtomicAddOut( T, C, V, O )    O = imageAtomicAdd( T, C, V )

#if defined( D_TEXTURE_FEEDBACK )

    #define texture2D( T, C )               Tex2dFeedback( T, T##FB, C )

    #define texture2DLod( T, C, N )         Tex2dLodFeedback( T, T##FB, C, N )  
    #define texture2DArray(  T, C )         Tex2dArrayFeedback( T, T##FB, C )

    #define texture3D( S, UV )              Tex3dFeedback( S, S##FB, UV )
    #define texture3DLod( S, UV, LOD )      Tex3dLodFeedback( S, S##FB, UV, LOD )

    #define SAMPLER2DARG( NAME )            in sampler2D NAME, in int NAME##FB
    #define SAMPLER2DPARAM( NAME )          NAME, NAME##FB

    #define SAMPLER2DARRAYARG( NAME )       in sampler2DArray NAME, in int NAME##FB
    #define SAMPLER2DARRAYPARAM( NAME )     NAME, NAME##FB

    #define SAMPLER2D( NAME )               sampler2D       NAME; int NAME##FB
    #define SAMPLER2DARRAY( NAME )          sampler2DArray  NAME; int NAME##FB
    #define SAMPLER3D( NAME )               sampler3D       NAME; int NAME##FB
    #define SAMPLER2DSHADOW_SRT( NAME )     sampler2DShadow NAME; int NAME##FB

#else

    #define texture2DLod( S, UV, LOD )      textureLod( S, UV, LOD )
    #define texture3DLod( S, UV, LOD )      textureLod( S, UV, LOD )

    #define SAMPLER2DARG( NAME )            in sampler2D NAME
    #define SAMPLER2DPARAM( NAME )          NAME

    #define SAMPLER2DARRAYARG( NAME )       in sampler2DArray NAME
    #define SAMPLER2DARRAYPARAM( NAME )     NAME

    #define SAMPLER2D( NAME )               sampler2D       NAME
    #define SAMPLER2DARRAY( NAME )          sampler2DArray  NAME
    #define SAMPLER3D( NAME )               sampler3D       NAME
    #define SAMPLER2DSHADOW_SRT( NAME )     sampler2DShadow NAME
#endif

    #define textureGatherRed(   lTex, lSamp ) textureGather( lTex, lSamp, 0 )
    #define textureGatherGreen( lTex, lSamp ) textureGather( lTex, lSamp, 1 )
    #define textureGatherBlue(  lTex, lSamp ) textureGather( lTex, lSamp, 2 )
    #define textureGatherAlpha( lTex, lSamp ) textureGather( lTex, lSamp, 3 )

    #define texture2DComputeGrad( T, C )    texture2D( T, C )

#elif defined(D_PLATFORM_ORBIS)

    #define SAMPLERCUBE( NAME, REG )        SamplerState NAME##SS : register( s##REG ); TextureCube NAME##TU : register( t##REG )

    #define SAMPLER2D( NAME )               Texture2D NAME; SamplerState NAME##SS
    #define SAMPLER2DSHADOW_SRT( NAME )     Texture2D NAME; SamplerComparisonState NAME##SS  //SAMPLER2D( NAME )
    #define SAMPLER3D( NAME )               Texture3D NAME; SamplerState NAME##SS


    #define SAMPLER2DARRAY( NAME )          Texture2D_Array NAME; SamplerState NAME##SS
    #define SAMPLER2DARRAYARG( NAME )       Texture2D_Array NAME, SamplerState NAME##SS
    #define SAMPLER2DARRAYPARAM( NAME )     NAME, NAME##SS

    #define SAMPLER2DPARAM( NAME )          NAME, NAME##SS
    #define SAMPLER2DARG( NAME )            Texture2D NAME, SamplerState NAME##SS

    #define texture2D( T, C )		        T.Sample( T##SS, C )

#if defined(D_PLATFORM_ORBIS_COMPUTE)
    #define texture2DComputeGrad( T, C )    T.SampleGradient( T##SS, C, vec2( dFdx( C ) ), vec2( dFdy( C ) ) )
    #define shadow2D( T, C )                T.SampleCmpLOD0( T##SS, C.xy, C.z )
#else
    #define texture2DComputeGrad( T, C )    T.Sample( T##SS, C )
    #define shadow2D( T, C )                T.SampleCmp( T##SS, C.xy, C.z )
#endif

    #define texture2DLod( T, C, N )         T.SampleLOD( T##SS, C, N )
    #define texture2DArray(  T, C )         T.Sample( T##SS, C )
    #define texture3DLod( T, C, N )         T.SampleLOD( T##SS, C, N )

    //#define shadow2D( T, C )                vec3( C.z > T.Sample( T##SS, C.xy ).x ? 1.0 : 0.0 )                    
    //#define shadow2D( T, C )                T.GatherCmp( T##SS, C.xy, C.z )
    //#define shadow2D( T, C )                T.SampleCmpLOD0( T##SS, C.xy, C.z )
    #define textureCube( T, C )		        T##TU.Sample( T##SS, C )
    #define textureCubeLod( T, C, N )	    T##TU.Sample( T##SS, C, N )
    #define textureGrad( T, C, DDX, DDY )   T.SampleGradient( T##SS, C, DDX, DDY )                    

    #define imageAtomicAdd( T, C, V )       AtomicAdd( T[ C ], V )
    #define imageAtomicAddOut( T, C, V, O )    AtomicAdd( T[ C ], V, O )

    #define imageStore( T, C, V )           ( T[C] = V )

    #define textureGatherRed(   lTex, lSamp ) lTex.GatherRed  ( lTex##SS, lSamp )
    #define textureGatherGreen( lTex, lSamp ) lTex.GatherGreen( lTex##SS, lSamp )
    #define textureGatherBlue(  lTex, lSamp ) lTex.GatherBlue ( lTex##SS, lSamp )
    #define textureGatherAlpha( lTex, lSamp ) lTex.GatherAlpha( lTex##SS, lSamp )

    #define texelFetch( lTex, lSamp, lLod ) lTex.MipMaps((lLod), (lSamp))

#endif


#if defined(D_PLATFORM_ORBIS_COMPUTE)

    #define THREADGROUP_LOCAL    thread_group_memory
    #define THREADGROUP_BARRIER  ThreadGroupMemoryBarrier()

#elif defined(D_PLATFORM_PC_COMPUTE)

    #define THREADGROUP_LOCAL    layout( shared )
    #define THREADGROUP_BARRIER  groupMemoryBarrier()

#endif

// =================================================================================================
// Matrices
// =================================================================================================
#ifdef D_PLATFORM_PC

    #define MUL( INPUT_A, INPUT_B )         (INPUT_A * INPUT_B)
    #define PLATFORM_TRANSPOSE
    #define MAT4_SET_POS( M, P )            M[ 3 ] = P
    #define MAT4_SET_TRANSLATION( M, T )    M[ 3 ].xyz = T
    #define MAT4_GET_COLUMN( M, C )         M[ C ].xyz
    #define MAT3_GET_COLUMN( M, C )         M[ C ]
    #define MAT4_GET_COLUMN_VEC4( M, C )    M[ C ]

    #define MAT3_SET_COLUMN( M, C, V )      M[ C ] = V;
    #define MAT4_SET_COLUMN( M, C, V )      M[ C ] = V;

#elif defined(D_PLATFORM_ORBIS)

    #define MUL( INPUT_A, INPUT_B )         mul( INPUT_B, INPUT_A )
    #define PLATFORM_TRANSPOSE
    #define MAT4_SET_POS( M, P )            M[ 3 ] = P
    #define MAT4_SET_TRANSLATION( M, T )    M[ 3 ].xyz = T
    #define MAT4_GET_COLUMN( M, C )         M[ C ].xyz
    #define MAT3_GET_COLUMN( M, C )         M[ C ]
    #define MAT4_GET_COLUMN_VEC4( M, C )    M[ C ]

    #define MAT3_SET_COLUMN( M, C, V )      M[ C ] = V;
    #define MAT4_SET_COLUMN( M, C, V )      M[ C ] = V;

#endif

// =================================================================================================
// Arrays (workaround AMD shader compiler issues by making arrays have global scope)
// =================================================================================================

#if defined(D_PLATFORM_ORBIS)

#define ARRAY_LOOKUP_FS( _UNIFORMS, _ELEMENT, _INDEX)   _UNIFORMS._ELEMENT[_INDEX]
#define ARRAY_LOOKUP_FP( _UNIFORMS, _ELEMENT, _INDEX)   _UNIFORMS->_ELEMENT[_INDEX]

#else

#define ARRAY_LOOKUP_FS( _UNIFORMS, _ELEMENT, _INDEX)   _ELEMENT[_INDEX]
#define ARRAY_LOOKUP_FP( _UNIFORMS, _ELEMENT, _INDEX)   _ELEMENT[_INDEX]

#endif


// =================================================================================================
// Input and Output
// =================================================================================================
#ifdef D_PLATFORM_PC

    #define UNIFORM( TYPE, NAME )           uniform TYPE NAME
    #define UNIFORM_SRT( TYPE, NAME )       uniform TYPE NAME

    #define DECLARE_INPUT
    #define DECLARE_OUTPUT
    #define DECLARE_END  
    #define DECLARE_PTR( TYPE, NAME )       TYPE  NAME;

    #define DECLARE_PATCH_INPUT_TRI
    #define DECLARE_PATCH_OUTPUT_TRI
    #define IN_PATCH_TRI_TESS_CONSTANTS
    #define OUT_PATCH_TRI_TESS_CONSTANTS

    #define DECLARE_PATCH_INPUT_QUAD
    #define DECLARE_PATCH_OUTPUT_QUAD
    #define IN_PATCH_QUAD_TESS_CONSTANTS
    #define OUT_PATCH_QUAD_TESS_CONSTANTS

    #if defined( D_HULL )

    #define INPUT(   TYPE, NAME, REG )      in    TYPE NAME [];
    #define INPUT_NOINTERP(   TYPE, NAME, REG )   flat   in    TYPE NAME [];
    #define INPUT_NOPERSP(   TYPE, NAME, REG )    in    TYPE NAME [];

    #define PATCH_OUTPUT(  TYPE, NAME, REG )      patch out   TYPE NAME;
    #define OUTPUT(  TYPE, NAME, REG )      out   TYPE NAME [];
    #define OUTPUT_NOINTERP(  TYPE, NAME, REG )   flat   out   TYPE NAME [];
    #define OUTPUT_NOPERSP(  TYPE, NAME, REG )    out   TYPE NAME [];

    #elif defined( D_DOMAIN )

    #define PATCH_INPUT(   TYPE, NAME, REG )      patch in    TYPE NAME;
    #define INPUT(   TYPE, NAME, REG )      in    TYPE NAME [];
    #define INPUT_NOINTERP(   TYPE, NAME, REG )   flat   in    TYPE NAME [];
    #define INPUT_NOPERSP(   TYPE, NAME, REG )    in    TYPE NAME [];

    #define OUTPUT(  TYPE, NAME, REG )            out   TYPE NAME;
    #define OUTPUT_NOINTERP(  TYPE, NAME, REG )   flat   out   TYPE NAME;
    #define OUTPUT_NOPERSP(  TYPE, NAME, REG )    out   TYPE NAME;

    #else

    #define INPUT(   TYPE, NAME, REG )      in    TYPE NAME;
    #define INPUT_NOINTERP(   TYPE, NAME, REG )   flat   in    TYPE NAME;
    #define INPUT_NOPERSP(   TYPE, NAME, REG )       in    TYPE NAME;

    #define OUTPUT(  TYPE, NAME, REG )      out   TYPE NAME;
    #define OUTPUT_NOINTERP(  TYPE, NAME, REG )   flat   out   TYPE NAME;
    #define OUTPUT_NOPERSP(  TYPE, NAME, REG )       out   TYPE NAME;

    #endif

    #define FRAGMENT_COLOUR_UVEC4_DEFINE    layout(location = 0) out uvec4 outu_color0;
    #define FRAGMENT_COLOUR_UVEC4           outu_color0

    #define FRAGMENT_COLOUR                 out_color0
    #define FRAGMENT_COLOUR0                out_color0
    #define FRAGMENT_COLOUR1                out_color1
    #define FRAGMENT_COLOUR2                out_color2
    #define FRAGMENT_COLOUR3                out_color3
    #define FRAGMENT_COLOUR4                out_color4
    #if defined( D_TAA_RENDER_TARGETS )	
        #define FRAGMENT_COLOUR_VEC4_DEFINE     layout(location = 0) out vec4 out_color0;  layout(location = 1) out vec4 out_color1;  layout(location = 2) out vec4 out_color2;	
    #elif !defined(D_ATTRIBUTES)
        #define FRAGMENT_COLOUR_VEC4_DEFINE     layout(location = 0) out vec4 out_color0;
    #else
        #define FRAGMENT_COLOUR_VEC4_DEFINE     layout(location = 0) out vec4 out_color0;  layout(location = 1) out vec4 out_color1;  layout(location = 2) out vec4 out_color2; layout(location = 3) out vec4 out_color3; layout(location = 4) out vec4 out_color4;
    #endif    
    #define FRAGMENT_COLOUR01_VEC4_DEFINE       layout(location = 0) out vec4 out_color0;  layout(location = 1) out vec4 out_color1;

    #define FRAGMENT_DEPTH                  gl_FragDepth
    #define FRAGMENT_FRONTFACE              gl_FrontFacing
    #define INPUT_FRONTFACING

    #define DEREF_PTR( VAR )                VAR

    #if defined( D_HULL ) 

    #define IN(  VAR )                      VAR[ gl_InvocationID ]
    #define OUT( VAR )                      VAR[ gl_InvocationID ]
    #define PATCH_OUT( VAR )                VAR

    #define OUTPUT_VERTEX_SCREEN_POSITION   gl_out[ gl_InvocationID ].gl_Position
    #define INPUT_VERTEX_SCREEN_POSITION    gl_in [ gl_InvocationID ].gl_Position

    #define TESS_LEVEL_EDGE( IND )          gl_TessLevelOuter[ IND ]
    #define TESS_LEVEL_INNER( IND )         gl_TessLevelInner[ IND ]

    #elif defined( D_DOMAIN )

    #define PATCH_IN(  VAR, IND )           VAR[ IND ]
    #define IN(  VAR, IND )                 VAR[ IND ]
    #define OUT( VAR )                      VAR

    #define INPUT_VERTEX_SCREEN_POSITION( IND )       gl_in [ IND ].gl_Position

    #define DOMAIN_COORDS                   gl_TessCoord

    #elif defined( D_GEOMETRY )

    #define OUTPUT_VERTEX_SCREEN_POSITION          gl_Position
    #define INPUT_VERTEX_SCREEN_POSITION( IND )    gl_in [ IND ].gl_Position
    #define IN(  VAR, IND )                   VAR[ IND ]
    #define OUT( VAR )                        VAR

    #else

    #define IN(  VAR )                      VAR
    #define OUT( VAR )                      VAR

    #endif

    #define OUT_VERTEX_SCREEN_POSITION 
    #define IN_SCREEN_POSITION 

    #define VERTEX_SCREEN_POSITION          gl_Position

#elif defined(D_PLATFORM_ORBIS_COMPUTE)

    #define DECLARE_INPUT                   struct cInput  {
    #define DECLARE_END                     };
    #define DECLARE_PTR( TYPE, NAME )       TYPE* NAME;

    #define INPUT(   TYPE, NAME, REG )               TYPE NAME : REG;
    #define INPUT_NOINTERP(   TYPE, NAME, REG )      TYPE NAME : REG;

    #define IN_SCREEN_POSITION              

    #define FRAGMENT_COLOUR  lUniforms.mpCmpOutPerMesh->gOutTexture0[dispatchThreadID.xy] 
    #define FRAGMENT_COLOUR0 lUniforms.mpCmpOutPerMesh->gOutTexture0[dispatchThreadID.xy] 
    #define FRAGMENT_COLOUR1 lUniforms.mpCmpOutPerMesh->gOutTexture1[dispatchThreadID.xy] 
    #define FRAGMENT_COLOUR2 lUniforms.mpCmpOutPerMesh->gOutTexture2[dispatchThreadID.xy] 
    #define FRAGMENT_COLOUR3 lUniforms.mpCmpOutPerMesh->gOutTexture3[dispatchThreadID.xy] 
    #define FRAGMENT_COLOUR4 lUniforms.mpCmpOutPerMesh->gOutTexture4[dispatchThreadID.xy] 
    #define FRAGMENT_DEPTH   lUniforms.mpCmpOutPerMesh->gOutTextureDepth[dispatchThreadID.xy] 

    #define DEREF_PTR( VAR )                *VAR

#elif defined(D_PLATFORM_ORBIS)

    #define UNIFORM( TYPE, NAME )           ConstantBuffer NAME##CB{ TYPE NAME; };
    #define UNIFORM_SRT( TYPE, NAME )       ConstantBuffer NAME##CB{ TYPE NAME : S_SRT_DATA; };

    #define DECLARE_OUTPUT                  struct cOutput {
    #define DECLARE_INPUT                   struct cInput  {
    #define DECLARE_END                     };
    #define DECLARE_PTR( TYPE, NAME )       TYPE* NAME;

    #define INPUT(   TYPE, NAME, REG )               TYPE NAME : REG;
    #define INPUT_NOINTERP(   TYPE, NAME, REG )      nointerp TYPE NAME : REG;    	
    #define INPUT_NOPERSP(   TYPE, NAME, REG )       nopersp  TYPE NAME : REG;    	

    #define OUTPUT(  TYPE, NAME, REG )      TYPE NAME : REG;    
    #define OUTPUT_NOINTERP(  TYPE, NAME, REG )      nointerp TYPE NAME : REG;
    #define OUTPUT_NOPERSP(  TYPE, NAME, REG )       nopersp  TYPE NAME : REG;

    #define FRAGMENT_COLOUR_UVEC4_DEFINE
    #define FRAGMENT_COLOUR_UVEC4           Out.mColour
    #define FRAGMENT_COLOUR                 Out.mColour
    #define FRAGMENT_COLOUR0                Out.mColour0
    #define FRAGMENT_COLOUR1                Out.mColour1
    #define FRAGMENT_COLOUR2                Out.mColour2
    #define FRAGMENT_COLOUR3                Out.mColour3
    #define FRAGMENT_COLOUR4                Out.mColour4
    #define FRAGMENT_DEPTH                  Out.mDepth
    
    #define FRAGMENT_FRONTFACE              In.mbFrontFacing
    #define INPUT_FRONTFACING               bool mbFrontFacing : S_FRONT_FACE;

    #if defined( D_HULL ) 

    #define IN(  VAR )                      In[ uCPID ].VAR
    #define OUT( VAR )                      Out.VAR
    #define PATCH_OUT( VAR )                Out.VAR

    #define OUTPUT_VERTEX_SCREEN_POSITION   OUT( mScreenPositionVec4 )
    #define INPUT_VERTEX_SCREEN_POSITION    IN( mScreenPositionVec4 )

    #define TESS_LEVEL_EDGE( IND )          Out.edge_ts[ IND ]
    #define TESS_LEVEL_INNER( IND )         Out.insi_ts[ IND ]

    #define DECLARE_PATCH_OUTPUT_TRI        [DOMAIN_PATCH_TYPE("tri")]  struct HSConstantOutputData {
    #define OUT_PATCH_TRI_TESS_CONSTANTS    float edge_ts[3]            : S_EDGE_TESS_FACTOR;    \
                                            float insi_ts[1]            : S_INSIDE_TESS_FACTOR;

    #define DECLARE_PATCH_OUTPUT_QUAD       [DOMAIN_PATCH_TYPE("quad")] struct HSConstantOutputData (
    #define OUT_PATCH_QUAD_TESS_CONSTANTS   float edge_ts[4]            : S_EDGE_TESS_FACTOR;    \
                                            float insi_ts[2]            : S_INSIDE_TESS_FACTOR;

    #define PATCH_OUTPUT(   TYPE, NAME, REG )               TYPE NAME : REG;

    #elif defined( D_DOMAIN )

    #define PATCH_IN(  VAR, IND )           patchIn.VAR
    #define IN(  VAR, IND )                 In[ IND ].VAR
    #define OUT( VAR )                      Out.VAR

    #define OUTPUT_VERTEX_SCREEN_POSITION        OUT( mScreenPositionVec4 )
    #define INPUT_VERTEX_SCREEN_POSITION( IND )  IN( mScreenPositionVec4, IND )

    #define DOMAIN_COORDS                   domainCoordinates

    #define DECLARE_PATCH_INPUT_TRI         [DOMAIN_PATCH_TYPE("tri")]  struct HSConstantOutputData {
    #define IN_PATCH_TRI_TESS_CONSTANTS     float edge_ts[3]            : S_EDGE_TESS_FACTOR;    \
                                            float insi_ts[1]            : S_INSIDE_TESS_FACTOR;

    #define DECLARE_PATCH_INPUT_QUAD        [DOMAIN_PATCH_TYPE("quad")] struct HSConstantOutputData {
    #define IN_PATCH_QUAD_TESS_CONSTANTS    float edge_ts[4]            : S_EDGE_TESS_FACTOR;    \
                                            float insi_ts[2]            : S_INSIDE_TESS_FACTOR;

    #define PATCH_INPUT(   TYPE, NAME, REG )               TYPE NAME : REG;

    #elif defined( D_GEOMETRY )

    #define IN(  VAR, IND )                 In[ IND ].VAR
    #define OUT( VAR )                      Out.VAR

    #define OUTPUT_VERTEX_SCREEN_POSITION        OUT( mScreenPositionVec4 )
    #define INPUT_VERTEX_SCREEN_POSITION( IND )  IN( mScreenPositionVec4, IND )

    #define EMIT_VERTEX                     TriStream.Append( Out )
    #define END_PRIMITIVE                   TriStream.RestartStrip()

    #else

    #define IN(  VAR )                      In.VAR
    #define OUT( VAR )                      Out.VAR

    #endif


// TODO get rid of this - don't pass struct through functinos, pass members.
    #define DEREF_PTR( VAR )                *VAR


    #define OUT_VERTEX_SCREEN_POSITION      OUTPUT( vec4, mScreenPositionVec4, S_POSITION )
    #define IN_SCREEN_POSITION              INPUT ( vec4, mScreenPositionVec4, S_POSITION )
    #define VERTEX_SCREEN_POSITION          OUT( mScreenPositionVec4 )

#endif

// =================================================================================================
// Main
// =================================================================================================
#ifdef D_PLATFORM_PC

    #define VERTEX_MAIN                         void main( void )
    #define VERTEX_MAIN_SRT                     uniform UniformBuffer lUniforms; void main( void )

    #define HULL_TRI_MAIN_SRT                   layout( vertices = 3 ) out; uniform UniformBuffer lUniforms; void main( void )
    #define HULL_QUAD_MAIN_SRT                  layout( vertices = 4 ) out; uniform UniformBuffer lUniforms; void main( void )

    #define DOMAIN_TRI_MAIN_SRT                 layout( triangles, fractional_even_spacing ) in; uniform UniformBuffer lUniforms; void main( void )
    #define DOMAIN_QUAD_MAIN_SRT                layout( quads, fractional_even_spacing ) in; uniform UniformBuffer lUniforms; void main( void )

    #define FRAGMENT_MAIN_COLOUR                FRAGMENT_COLOUR_VEC4_DEFINE void main( void )
    #define VOID_MAIN_COLOUR                    FRAGMENT_COLOUR_VEC4_DEFINE void main( void )
    #define FRAGMENT_MAIN_COLOUR_DEPTH          FRAGMENT_COLOUR_VEC4_DEFINE void main( void )

    #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT      FRAGMENT_COLOUR_VEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )
    #define FRAGMENT_MAIN_COLOUR_DEPTH_GE_SRT   FRAGMENT_COLOUR_VEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )
    #define FRAGMENT_MAIN_COLOUR_DEPTH_LE_SRT   FRAGMENT_COLOUR_VEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )
    #define FRAGMENT_MAIN_COLOUR_SRT            FRAGMENT_COLOUR_VEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )
    #define FRAGMENT_MAIN_COLOUR_EARLYZ_SRT     FRAGMENT_COLOUR_VEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )
    #define FRAGMENT_MAIN_UICOLOUR_SRT          FRAGMENT_COLOUR_UVEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )
	
    #define VOID_MAIN_SRT                       FRAGMENT_COLOUR_VEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )
    #define VOID_MAIN_DEPTH_SRT                 FRAGMENT_COLOUR_VEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )

    #define FRAGMENT_MAIN_COLOUR01_SRT          FRAGMENT_COLOUR01_VEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )
    #define FRAGMENT_MAIN_COLOUR01_DEPTH_SRT    FRAGMENT_COLOUR01_VEC4_DEFINE uniform UniformBuffer lUniforms; void main( void )

#elif defined( D_PLATFORM_PC_COMPUTE )

    #define COMPUTE_MAIN_SRT( X, Y, Z )         layout (local_size_x = X, local_size_y = Y, local_size_z = Z) in; void main( void )

    #define FRAGMENT_MAIN_COLOUR_SRT            COMPUTE_MAIN_SRT( 8,8,1 )
    #define FRAGMENT_MAIN_COLOUR01_SRT          COMPUTE_MAIN_SRT( 8,8,1 )
    #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT      COMPUTE_MAIN_SRT( 8,8,1 )

#elif defined( D_PLATFORM_ORBIS_COMPUTE )

    #define COMPUTE_MAIN_SRT( X, Y, Z )         [NUM_THREADS(X, Y, Z)]  void main(uint3 groupID : S_GROUP_ID, uint3 groupThreadID : S_GROUP_THREAD_ID, uint3 dispatchThreadID : S_DISPATCH_THREAD_ID, UniformBuffer lUniforms : S_SRT_DATA)

    #define FRAGMENT_MAIN_COLOUR_SRT            COMPUTE_MAIN_SRT( 8,8,1 )
    #define FRAGMENT_MAIN_COLOUR01_SRT          COMPUTE_MAIN_SRT( 8,8,1 )
    #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT      COMPUTE_MAIN_SRT( 8,8,1 )

#elif defined( D_PLATFORM_ORBIS )

    #define VERTEX_MAIN                     void main( cInput In, out cOutput Out )
    #define VERTEX_MAIN_SRT                 void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA  )

    #define HULL_TRI_MAIN_SRT               [DOMAIN_PATCH_TYPE("tri")]                  \
                                            [PARTITIONING_TYPE("integer")]              \
                                            [OUTPUT_TOPOLOGY_TYPE("triangle_cw")]       \
                                            [OUTPUT_CONTROL_POINTS(3)]                  \
                                            [PATCH_CONSTANT_FUNC("ConstantsHS")]        \
                                            [MAX_TESS_FACTOR(16.0)]                     \
                                            void main(                                  \
                                                InputPatch<cInput, 3> In,               \
                                                uint uCPID : S_OUTPUT_CONTROL_POINT_ID, \
                                                UniformBuffer lUniforms : S_SRT_DATA,   \
                                                out cOutput Out )

    #define HULL_QUAD_MAIN_SRT              [DOMAIN_PATCH_TYPE("quad")]                 \
                                            [PARTITIONING_TYPE("integer")]              \
                                            [OUTPUT_TOPOLOGY_TYPE("triangle_cw")]       \
                                            [OUTPUT_CONTROL_POINTS(4)]                  \
                                            [PATCH_CONSTANT_FUNC("ConstantsHS")]        \
                                            [MAX_TESS_FACTOR(16.0)]                     \
                                            void main(                                  \
                                                InputPatch<cInput, 4> In,               \
                                                uint uCPID : S_OUTPUT_CONTROL_POINT_ID, \
                                                UniformBuffer lUniforms : S_SRT_DATA,   \
                                                out cOutput Out )


    #define DOMAIN_TRI_MAIN_SRT             [DOMAIN_PATCH_TYPE("tri")]                  \
                                            void main(                                  \
                                                HSConstantOutputData patchIn,           \
                                                const OutputPatch<cInput, 3> In,        \
                                                out cOutput Out,                        \
                                                UniformBuffer lUniforms : S_SRT_DATA,   \
                                                float3 domainCoordinates : S_DOMAIN_LOCATION )

    #define DOMAIN_QUAD_MAIN_SRT            [DOMAIN_PATCH_TYPE("quad")]                 \
                                            void main(                                  \
                                                HSConstantOutputData patchIn,           \
                                                const OutputPatch<cInput, 4> In,        \
                                                out cOutput Out,                        \
                                                UniformBuffer lUniforms : S_SRT_DATA,   \
                                                float2 domainCoordinates : S_DOMAIN_LOCATION )

    #define GEOMETRY_MAIN_SRT( MAX_VERTS ) cOutput Out; [MAX_VERTEX_COUNT(MAX_VERTS)] void main( inout TriangleBuffer<cOutput> TriStream, Triangle cInput In[3], UniformBuffer lUniforms : S_SRT_DATA )


#define FRAGMENT_MAIN_COLOUR            struct cOutput { vec4  mColour : S_TARGET_OUTPUT; };									[RE_Z] void main( cInput In, out cOutput Out )
#define VOID_MAIN_COLOUR                struct cOutput { vec4  mColour : S_TARGET_OUTPUT; };									       void main( cInput In, out cOutput Out )
#define FRAGMENT_MAIN_COLOUR_DEPTH      struct cOutput { vec4  mColour : S_TARGET_OUTPUT; float mDepth  : S_DEPTH_OUTPUT; };	[RE_Z] void main( cInput In, out cOutput Out )
#define VOID_MAIN_SRT                       	                                	     										       void main( cInput In, UniformBuffer lUniforms : S_SRT_DATA )

    #if defined( D_TAA_RENDER_TARGETS )

        #define FRAGMENT_MAIN_COLOUR_SRT        struct cOutput { vec4  mColour0 : S_TARGET_OUTPUT0;    \
                                                                 vec4  mColour1 : S_TARGET_OUTPUT1;    \
                                                                 vec4  mColour2 : S_TARGET_OUTPUT2; }; \
                                                [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )


    #elif !defined( D_ATTRIBUTES )
#define FRAGMENT_MAIN_COLOUR_DEPTH_SRT     struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_OUTPUT;    }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA  )
#define FRAGMENT_MAIN_COLOUR_DEPTH_GE_SRT  struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_GE_OUTPUT; }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA  )
#define FRAGMENT_MAIN_COLOUR_DEPTH_LE_SRT  struct cOutput { vec4 mColour : S_TARGET_OUTPUT; float mDepth : S_DEPTH_LE_OUTPUT; }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA  )
#define FRAGMENT_MAIN_COLOUR_SRT           struct cOutput { vec4  mColour : S_TARGET_OUTPUT; };	                                        void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )
#define VOID_MAIN_DEPTH_SRT                struct cOutput {                                 float mDepth : S_DEPTH_OUTPUT;    }; [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA  )
#define VOID_MAIN_COLOUR_EARLYZ_SRT        	                                								[FORCE_EARLY_DEPTH_STENCIL] void main( cInput In, UniformBuffer lUniforms : S_SRT_DATA )

#define FRAGMENT_MAIN_COLOUR01_SRT         struct cOutput { vec4  mColour0 : S_TARGET_OUTPUT0;    \
                                                            vec4  mColour1 : S_TARGET_OUTPUT1; }; \
                                                [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )
#define FRAGMENT_MAIN_COLOUR01_DEPTH_SRT   struct cOutput { vec4  mColour0 : S_TARGET_OUTPUT0;  \
                                                            vec4  mColour1 : S_TARGET_OUTPUT1;  \
                                                            float mDepth   : S_DEPTH_OUTPUT; }; \
                                                [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA  )

    #else
        
        // #pragma PSSL_target_output_format(target 1 FMT_32_AR)
    
        #define FRAGMENT_MAIN_COLOUR_DEPTH_SRT  struct cOutput { vec4  mColour0 : S_TARGET_OUTPUT0;  \
                                                                 vec4  mColour1 : S_TARGET_OUTPUT1;  \
                                                                 vec4  mColour2 : S_TARGET_OUTPUT2;  \
                                                                 vec4  mColour3 : S_TARGET_OUTPUT3;  \
                                                                 float mDepth   : S_DEPTH_OUTPUT; }; \
                                                [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA  )

        #define FRAGMENT_MAIN_COLOUR_SRT        struct cOutput { vec4  mColour0 : S_TARGET_OUTPUT0;    \
                                                                 vec4  mColour1 : S_TARGET_OUTPUT1;    \
                                                                 vec4  mColour2 : S_TARGET_OUTPUT2;    \
                                                                 vec4  mColour3 : S_TARGET_OUTPUT3; }; \
                                                [RE_Z] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )
                                                    
        #define FRAGMENT_MAIN_COLOUR_EARLYZ_SRT        struct cOutput { vec4  mColour0 : S_TARGET_OUTPUT0;    \
                                                                 vec4  mColour1 : S_TARGET_OUTPUT1;    \
                                                                 vec4  mColour2 : S_TARGET_OUTPUT2;    \
                                                                 vec4  mColour3 : S_TARGET_OUTPUT3; }; \
                                                [FORCE_EARLY_DEPTH_STENCIL] void main( cInput In, out cOutput Out, UniformBuffer lUniforms : S_SRT_DATA )                                                    
    #endif


#endif

// =================================================================================================
// Texture resolution
// =================================================================================================

#ifdef D_PLATFORM_ORBIS
uvec2 GetResolution( Texture2D lTexture )
{
    uvec2 lResolution;
    lTexture.GetDimensionsFast(lResolution.x, lResolution.y);
    return lResolution;
}

uvec2 GetResolution( RW_Texture2D<float4> lTexture )
{
    uvec2 lResolution;
    lTexture.GetDimensionsFast(lResolution.x, lResolution.y);
    return lResolution;
}
#else
uvec2 GetResolution( sampler2D lTexture )
{
    return textureSize( lTexture, 0 );
}
#endif

// =================================================================================================
// Viewport
// =================================================================================================
#ifdef D_PLATFORM_PC

    #define SCREENSPACE_AS_RENDERTARGET_UVS( A ) A.xy

#elif defined(D_PLATFORM_ORBIS)

    #define SCREENSPACE_AS_RENDERTARGET_UVS( A ) ( float2( A.x, 1.0 - A.y ) )

#endif

#ifdef D_USING_LOGDEPTH
    
    #define D_DEPTH_CLEARVALUE (1.0)

#else

    #define D_DEPTH_CLEARVALUE (0.0)

#endif

// =================================================================================================
// Texture usage feedback
// =================================================================================================
#if defined( D_TEXTURE_FEEDBACK ) && defined( D_PLATFORM_PC )

layout(r32i) uniform  iimage2D gTexFeedbackImg;

void WriteTexFeedback( in int liCounter, in float liMip )
{
    if( liCounter != 0 )
    {
        #if defined( GL_ARB_shader_ballot ) && ( GL_ARB_shader_ballot == 1 )
        if( readFirstInvocationARB( gl_SubGroupInvocationARB ) == gl_SubGroupInvocationARB )
        #endif
        {
            int liIntMip = int(floor(liMip));
            //imageStore( gTexFeedbackImg, ivec2( liCounter, liIntMip ), ivec4(1,0,0,0) );
            imageAtomicAdd( gTexFeedbackImg, ivec2( liCounter, liIntMip ), int(1) );
        }
    }
}

vec4 Tex2dFeedback( in sampler2D lSamp, in int liCounter, in vec2 lCoords )
{
    float liLod = textureQueryLOD( lSamp, lCoords ).x;
    WriteTexFeedback( liCounter, liLod );
    return texture( lSamp, lCoords );
}

vec4 Tex2dLodFeedback( in sampler2D lSamp, in int liCounter, in vec2 lCoords, in float liLod )
{
    WriteTexFeedback( liCounter, liLod );
    return textureLod( lSamp, lCoords, liLod );
}

vec4 Tex2dArrayFeedback( in sampler2DArray lSamp, in int liCounter, in vec3 lCoords )
{
    float liLod = textureQueryLOD( lSamp, lCoords.xy ).x;
    WriteTexFeedback( liCounter, liLod );
    return texture( lSamp, lCoords );
}

vec4 Tex3dFeedback( in sampler3D lSamp, in int liCounter, in vec3 lCoords )
{
    float liLod = textureQueryLOD( lSamp, lCoords ).x;
    WriteTexFeedback( liCounter, liLod );
    return texture( lSamp, lCoords );
}

vec4 Tex3dLodFeedback( in sampler3D lSamp, in int liCounter, in vec3 lCoords, in float liLod )
{
    WriteTexFeedback( liCounter, liLod );
    return textureLod( lSamp, lCoords, liLod );
}


#endif

#endif